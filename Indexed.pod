##========================================================================
## POD DOCUMENTATION, auto-generated by podextract.perl
=pod

=cut

##========================================================================
## NAME
=pod

=head1 NAME

Tie::File::Indexed - tied array access to indexed data files

=cut

##========================================================================
## SYNOPSIS
=pod

=head1 SYNOPSIS

 ##========================================================================
 ## PRELIMINARIES
 
 use Tie::File::Indexed;
 
 ##========================================================================
 ## Tied Array access
 
 ##-- tie an array (uses files "data", "data.idx", and "data.hdr")
 my $filename = "data";
 tie(my @data, 'Tie::File::Indexed', $filename, %options) or die ...
 
 ##-- add some data
 $data[42] = 'blah';      # set an item
 $data[42] = 'blip';      # overwrite an item (really appends a new record)
 $data[24] = 'bonk';      # out-of-order storage
 print $data[42];         # retrieve & print a stored value
 
 ##-- tweak array size
 $n_items = @data;        # get number of stored records
 $#data -= 2;             # chop two records off the end
 
 ##-- consolidate records (remove gaps and stale values)
 tied(@data)->consolidate();
 
 ##-- all done
 untie(@data);

=cut

##========================================================================
## DESCRIPTION
=pod

=head1 DESCRIPTION

=cut

##----------------------------------------------------------------
## DESCRIPTION: Tie::File::Indexed: Constructors etc.
=pod

=head2 Constructors etc.

=over 4

=item new

 $tfi = CLASS->new(%opts);
 $tfi = CLASS->new($file,%opts);
 $tfi = tie(@array, CLASS, $file, %opts);

Creates and returns a new Tie::File::Indexed object, in the third form tying it to
the Perl array @array.  Currently accepted %options:

 file   => $file,    ##-- file basename; uses files "${file}", "${file}.idx", "${file}.hdr"
 mode   => $mode,    ##-- open mode (fcntl flags or perl-style; default='rwa')
 perms  => $perms,   ##-- default: 0666 & ~umask
 pack_o => $pack_o,  ##-- file offset pack template (default='N')
 pack_l => $pack_l,  ##-- string-length pack template (default='N')

When opening an existing file, administrative header-data is read from the header-file F<$file.hdr>,
which is written on close() if opened in write-mode.
Raw data records are read/written from/to the data-file F<$file>,
and their offsets and lengths are stored as packed integers in the index-file F<$file.idx>.
The options C<pack_o> and C<pack_l> control the pack-templates to use for the index-file.

=item defaults

 %defaults = CLASS_OR_OBJECT->defaults()

Default attributes for constructor; can be overridden by subclasses.

=item DESTROY

 undef = $tfi->DESTROY();

Destructor implicitly calls close().

=back

=cut

##----------------------------------------------------------------
## DESCRIPTION: Tie::File::Indexed: Subclass API: Data I/O
=pod

=head2 Subclass API: Data I/O

=over 4

=item writeData

 $bool = $tfi->writeData($data);

Write item $data to C<$tfi-E<gt>{datfh}> at its current position.
After writing, C<$tfi-E<gt>{datfh}> should be positioned to the first byte following the written item.
The object is assumed to be opened in write-mode.
Can be overridden by subclasses to perform transparent encoding of complex data.

=item readData

 $data_or_undef = $tfi->readData($offset,$length);

Read item data from C<$tfi-E<gt>{datfh}> from its current position.
Can be overridden by subclasses to perform transparent encoding of complex data.

=back

=cut

##----------------------------------------------------------------
## DESCRIPTION: Tie::File::Indexed: Object API: header
=pod

=head2 Object API: header

=over 4

=item headerKeys

 @keys = $tfi->headerKeys();

Keys to save as header.

=item headerData

 \%header = $tfi->headerData();

Data to save as header.

=item loadHeader

 $tfi_or_undef = $tfi->loadHeader();
 $tfi_or_undef = $tfi->loadHeader($headerFile,%opts);

Loads header from C<$headerFile>, by default C<"$tfi->{file}.hdr">.

=item saveHeader

 $tfi_or_undef = $tfi->saveHeader();
 $tfi_or_undef = $tfi->saveHeader($headerFile);

Saves header data to C<$headerFile>, by default C<"$tfi->{file}.hdr">.

=back

=cut

##----------------------------------------------------------------
## DESCRIPTION: Tie::File::Indexed: Object API: open/close
=pod

=head2 Object API: open/close

=over 4

=item open

 $tfi_or_undef = $tfi->open($file,$mode);
 $tfi_or_undef = $tfi->open($file);
 $tfi_or_undef = $tfi->open();

Opens underlying file(s) for use.

=item close

 $tfi_or_undef = $tfi->close();

Close any opened files, writes header if opened in write mode.

=item opened

 $bool = $tfi->opened();

Returns true iff object is opened.

=item flush

 $tfi_or_undef = $tfi->flush();

Attempts to flush underlying filehandles using their C<flush()> method, if available.
Also writes header file.

=back

=cut

##----------------------------------------------------------------
## DESCRIPTION: Tie::File::Indexed: Object API: consolidate
=pod

=head2 Object API: consolidate

=over 4

=item consolidate

 $tfi_or_undef = $tfi->consolidate();
 $tfi_or_undef = $tfi->consolidate($tmpfile);

Consolidates file data: ensures that data in C<$tfi-E<gt>{datfh}> are in index-order and contain no gaps or unused blocks.
The object must be opened in write-mode.
Uses C<$tmpfile> as a temporary file for consolidation (default=C<"$tfi-E<gt>{file}.tmp">).

If you never overwrite data in your tied arrays, you probably won't need this method.
It can be useful to reduce the size of the associated data-file and/or optimize index-ordered access operations, since
(over)writing any existing array item causes a new record to be appended to the data-file.
Consider the following code:

 tie(my @data, 'Tie::File::Indexed', "data") or die ...  ##-- tie the array
 $data[1] = 'bar';                                       ##-- data-file is now "foobar"
 $data[0] = 'foo';                                       ##-- data-file is now "barfoo"
 $data[1] = 'baz';                                       ##-- data-file is now "barfoobaz"

Here, the element at index 0 ("foo") is stored "out-of-order", since its phyiscal location in
the data-file (2nd record) does not correspond to its logical location in the array (1st element).
Further, the 1st record in the data-file ("bar") is unused, since it was overwritten
by the value C<"baz"> stored in the 3rd data-file record.  The index-file takes care of resolving
the offset and length of the logical array elements (so that e.g. C<$data[1] eq 'baz'> rather
than C<'bar'>), but no effort is made to re-use unreferenced material in the data-file,
so that the original value for C<$data[1]> is effectively orphaned.  Calling C<consolidate()>
at this point ensures that the disk-files are logically sorted and contain no unreferenced
material:

 tied(@data)->consolidate();                             ##-- data-file is now "foobaz"

This method is never implicitly called, so if you need it, you'll have to call it yourself.

=back

=cut


##========================================================================
## END POD DOCUMENTATION, auto-generated by podextract.perl
=pod

=cut

##======================================================================
## TODO
##======================================================================
=pod

=head1 TODO

Shortcuts for advisory locking might be nice.

=back

##======================================================================
## Footer
##======================================================================
=pod

=head1 AUTHOR

Bryan Jurish E<lt>moocow@cpan.orgE<gt>

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2015 by Bryan Jurish

This package is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.20.2 or,
at your option, any later version of Perl 5 you may have available.

=cut


=cut
